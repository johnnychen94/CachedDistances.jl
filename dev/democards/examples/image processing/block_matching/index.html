<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Block matching · LazyDistances</title><link rel="canonical" href="https://johnnychen94.github.io/LazyDistances.jl/democards/examples/image processing/block_matching/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LazyDistances</span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox" checked/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Image processing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Block matching</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">Image processing</a></li><li class="is-active"><a href>Block matching</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Block matching</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/johnnychen94/LazyDistances.jl/blob/master/docs/examples/image processing/block_matching.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Block-matching"><a class="docs-heading-anchor" href="#Block-matching">Block matching</a><a id="Block-matching-1"></a><a class="docs-heading-anchor-permalink" href="#Block-matching" title="Permalink"></a></h1><p><a href="../block_matching.jl"><img src="https://img.shields.io/badge/download-julia-brightgreen.svg" alt="Source code"/></a> <a href="https://nbviewer.jupyter.org/github/johnnychen94/LazyDistances.jl/blob/gh-pages/dev/democards/examples/image processing/block_matching.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt="notebook"/></a> <img src="https://img.shields.io/badge/Author-Johnny%20Chen-blue" alt="Author"/> <img src="https://img.shields.io/date/1602720000" alt="Update time"/></p><p>Block matching algorithm is one key stage in patch-based image processing algorithm. This example shows how block matching algorithm can be implemented efficiently and easily with the help of LazyDistances.jl.</p><pre><code class="language-julia">using Images
using TestImages
using LazyDistances

img = imresize(float.(testimage(&quot;cameraman&quot;)), (64, 64))</code></pre><img src="data:image/png;base64,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" /><p>For given patch radius <code>rₚ</code>, we can get a patch at each pixel <code>p</code> in the image.</p><pre><code class="language-julia">p = CartesianIndex(20, 30)
rₚ = CartesianIndex(3, 3) # patch size (7, 7)
patch_p = img[p-rₚ:p+rₚ]</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAABpCAAAAAAc6VLmAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAADYSURBVGje7dmxCkFRHMfxe3RsCknJGyizB5DFYPUCnscjGCUPoDyC58BisiiiZP6e4W7HWb6/7Vv06b+43YR+ha2ZZ2by4VZVtzGzUf1rSkpKSkq5FibsC3PBHDG7zC9zU+omJSUlJaVci8mD4MrcM+fMNvPBHJS6SUlJSUkp1+KMfWOemAdm8hBZMbelblJSUlJSyrV4ZD+Zr9ovT5kf5rDUTUpKSkpKuRaSP7iTX/7kqRGYTeaO+S51k5KSkpJSroVO0szIXDJ7zOQ95V7qJiUlJSWlXPsB9wgXB3w8LXcAAAAASUVORK5CYII=" /><p>For each pixel <code>p</code>, what block matching does is to find a group of patches that are similar to <code>patch_p</code>.</p><pre><code class="language-julia">function block_matching(f, img, p, rₚ; num_patches=10)
    R = CartesianIndices(img)
    # to simplify the implementation and not consider border case
    candidates = first(R)+rₚ:last(R)-rₚ

    # Measure the similarity of two patches with `f`. Typically, `f` is `sqeuclidean`
    patch_p = @view img[p-rₚ:p+rₚ]
    dist = map(candidates) do q
        patch_q = @view img[q-rₚ:q+rₚ]
        f(patch_p, patch_q)
    end |&gt; vec

    # sort from small(the most similar) to large(the least similar)
    # TODO: use partialsortperm! to reduce allocation
    order = partialsortperm(dist, 1:num_patches) # 34.394 μs (4 allocations: 26.44 KiB)
    qs = @view candidates[order]
end</code></pre><pre class="documenter-example-output">block_matching (generic function with 1 method)</pre><p>Here we get a group of patches that are similar to <code>patch_p</code> in the sense of F-norm.</p><pre><code class="language-julia">matched_patches = block_matching(SqEuclidean(), img, p, rₚ) # 212.266 μs (7 allocations: 39.83 KiB)
mosaicview(map(q-&gt;img[q-rₚ:q+rₚ], matched_patches); npad=2, nrow=2)</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKwAAABACAAAAACi3MP9AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAMESURBVGje7dpBiFVVGAfw35u5Tow5Y6ONTiLUSIhNUWBC0E5xo9FKcFOLMAqKtmUiGEFBBCJt2raKcNdGiKAQ3BQuQoJwI0GlIGZSkzaTOtPiO9d3HO6ju7mLC+e/Ofe99+fc7378z3fP+f5vMIuT+AWz2CDwFJ5J15NYjwXcxgtYwgTeS5z1eAxX0jiFQ6jwVsZZTdcD7MXT2IS30/eP4Dj+TtyxxB1P171BCbYrVPM4ihfxIB7ACt7MSPNCi4tCi1OYSZ9r7MA1ofklPCQ0vbzmhoM0zgitLqb71biOT3HEUN/Laa5eZbYE2xWqJ/AbTuMANooaN5eRrmvWYq7ZCuuE/v7AQVzA9oyz6v56vdOwXtdYSPf/y/16v9W3zJZgu0K1H1fxHc4I3b6KzzPSKC3OZJxV3BU6W8UNPInLGadNvT6IU7iEbWm+KbE/6VVmS7BdofoK/4h6B/tEDdyWkUZpcTzjzOJh8e6/ge+xVdTfGm3q9SKm8Q1eSdfjaZ5eZbYE2xWqr4VGCb29gy/wXEZa0KzF/ElvCk3/LN7tB/Cv4f6VdvX6eTyOd4Vex3AnxdirzJZgu0J1W+hqCoexGWeFPmvc1KzFvBb/hN3YJc5ic2IPOp9x2tTrs6JfMYaPccJQ673KbAm2oKCgoKCfGCxo9gEWcSyRNon3d5P38FIaJ9PY5D18mH7brNmXWMH7iTONT8Te4o7YR6wY+gu9QQm2K1RtzvLP4k/N3kONgaEPtraXVeOu5j7XrYwzgY/EGvggzTumaLYEew9Vm7P8y/hWs/dQo40PNmptbMg4c/hdnNGOiB7FGymmXmW2BNsVqjZn+XP4P++hjQ82am3kGVsW/0HYK/oQr2GL0jcowd5D1ab3OoFR3kONNj7Ykua1kc8zLvbE03hd6PpL0WvrVWZLsF2hatN7PZ2eqsl7qNHGB9uteW2cX5O9i/hB1NdHRf3+rG+ZLcF2hWpSsw+QeworooY2eQ812vhgP2peG79mnLpeT4s1cB57hC/Wq8yWYLvCf4Xz6reKVbuSAAAAAElFTkSuQmCC" /><p>This implementation looks good, but there&#39;s one key challenge here, that we need to loop over the whole image and do block matching for each pixel. This means we are doing a massive computation and there are a lot of unnecessary redundant calculation if we are doing a simple loop.</p><p>For example, this is what a naive implementation of patch-based algorithm might looks like</p><pre><code class="language-julia">function patched_mean(img, rₚ; num_patches=10)
    out = fill(zero(eltype(img)), axes(img))

    R = CartesianIndices(img)
    for p in first(R)+rₚ:last(R)-rₚ
        matched_patches = block_matching(SqEuclidean(), img, p, rₚ; num_patches=num_patches)
        out[p] = mapreduce(q-&gt;img[q], +, matched_patches)/length(matched_patches)
    end
    out
end

patched_mean(img, rₚ) # 794.575 ms (23549 allocations: 130.86 MiB)</code></pre><img src="data:image/png;base64,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" /><p>What&#39;s wrong here? There are a lot of repeated calculation in <code>f(patch_q, patch_q)</code>. For example, when <code>f = SqEuclidean()</code></p><div>\[d = \sum_{p, q} (I[p] - I[q])^2\]</div><p>Please do note that <code>(I[p] -  I[q])^2</code> is repeatedly calculated in the whole iteration. One single calculation of such is not expensive, but it is a siginficant amount of work when it&#39;s in a nested for-loops.</p><p>Among all the existing MATLAB and Python implementations, there are two things done to work around this key challenge. The first workaround is to pre-calculate the pixelwise distances and then reuse it in the inner loop. It works quite well but it also introduces another key challenge, that the memeory will complain for large image size; to store the result for image with size <code>(256, 256)</code> we need an array of size <code>(256, 256, 256, 256)</code>, which is 32 GB memory and unaccptable. The second workaround, is then to specify a search window, that to only search similar patches in a larger neighborhood of pixel <code>p</code>. For search window size <code>(17, 17)</code>, the memeory needed to store the result is 0.14 GB, which is more acceptable.</p><p>We are not going to explore how search window and pre-calculation are implemented because this is quite a dirty work; you almost have to write the whole implementation in a long long for-loop. Instead, we are going to see how this can be efficiently and easily implemented with LazyDistances.jl.</p><p>A <a href="../../../../#LazyDistances.PairwiseDistance"><code>PairwiseDistance</code></a> is a lazy array that mimics the output of pairwise distance.</p><pre><code class="language-julia">eval_op(x, y) = abs2(x - y)
pointwise_dist = PairwiseDistance(eval_op, img, img); # 1.982 ns (0 allocations: 0 bytes)

# pointwise_dist[I, J] is defined as f(img[I], img[J])
pq1 = pointwise_dist[CartesianIndex(1, 1), CartesianIndex(2, 2)]
pq2 = eval_op(img[CartesianIndex(1, 1)], img[CartesianIndex(2, 2)])
pq1 == pq2</code></pre><pre class="documenter-example-output">true</pre><p>Generating this array does not doing any actual computation; the computation does not happen until you ask for the data. We can also build a patchwise distance with this.</p><pre><code class="language-julia">R = CartesianIndices(img)
valid_R = first(R)+rₚ:last(R)-rₚ

# For simplicity, we didn&#39;t deal with boundary condition here, so it will error
# when we index with `patchwise_dist[1, 1, 1, 1]`.
patchwise_dist = let rₚ = rₚ, img = img
        PairwiseDistance(SqEuclidean(), img, img) do p, q
        # here we specify how patches are generated from given pixel p and q
        p, q = CartesianIndex(p), CartesianIndex(q)
        @views img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ]
    end
end; # 4.903 ns (0 allocations: 0 bytes)

p = CartesianIndex(4, 4)
q = CartesianIndex(5, 5)
# @btime getindex($patchwise_dist, $p, $q) # 54.374 ns (0 allocations: 0 bytes)
patchwise_dist[p, q] == sqeuclidean(img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ])</code></pre><pre class="documenter-example-output">true</pre><p>This way we have generated the patchwise distances, although the actual computation doesn&#39;t happen until we need it.</p><pre><code class="language-julia">function patched_mean_fast(img, rₚ; num_patches=10)
    out = fill(zero(eltype(img)), axes(img))

    patchwise_dist = PairwiseDistance(SqEuclidean(), img, img) do p, q
        p, q = CartesianIndex(p), CartesianIndex(q)
        @views img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ]
    end

    R = CartesianIndices(img)
    R0 = first(R)+rₚ:last(R)-rₚ
    for p in R0
        dist = vec(patchwise_dist[p, R0])
        matched_patches = R0[partialsortperm(dist, 1:num_patches)]
        out[p] = mapreduce(q-&gt;img[q], +, matched_patches)/length(matched_patches)
    end
    out
end

# @btime patched_mean_fast($img, rₚ);
#  657.075 ms (26913 allocations: 131.63 MiB)
# @btime patched_mean($img, rₚ);
#  797.023 ms (23549 allocations: 130.86 MiB)
patched_mean_fast(img, rₚ) == patched_mean(img, rₚ)</code></pre><pre class="documenter-example-output">true</pre><p>Great! We haven&#39;t incoporate the pre-calculation trick yet, we still get a bit faster by making things lazy.</p><p>More generally speaking, pre-calculation is just a cache. <code>PairwiseDistance</code> supports a so-called <a href="democards/examples/image processing/@ref"><code>LocalWindow</code></a> cache which stores the results in neighborhood <code>(p, q-r:q+r)</code> for each pixel pair <code>(p, q)</code>.</p><pre><code class="language-julia">eval_op(x, y) = abs2(x - y)
pointwise_dist = PairwiseDistance(eval_op, img, img, LocalWindowCache((7, 7))) # 32.575 μs (3 allocations: 980.12 KiB)

pq1 = pointwise_dist[CartesianIndex(1, 1), CartesianIndex(2, 2)]
pq2 = eval_op(img[CartesianIndex(1, 1)], img[CartesianIndex(2, 2)])
pq1 == pq2</code></pre><pre class="documenter-example-output">true</pre><p>This requires a bit more memory because we will allocate a cache array of size <code>(64, 64, 7, 7)</code>, which is about 788 KB memory for Float32 type. Reusing the cache requires us to implement the SqEuclidean function on it. Lucikly we can get this done very efficiently and quickly in Julia.</p><pre><code class="language-julia">patchwise_dist = let img=img, rₚ=rₚ
        eval_op(x, y) = abs2(x - y)
        pointwise_dist = PairwiseDistance(eval_op, img, img, LocalWindowCache((7, 7)))

        patch_eval_op(patch_p, patch_q) = mapreduce((p, q)-&gt;pointwise_dist[p, q], +, patch_p, patch_q)
        PairwiseDistance{Float32}(patch_eval_op, img, img) do p, q
        p, q = CartesianIndex(p), CartesianIndex(q)
        p-rₚ:p+rₚ, q-rₚ:q+rₚ
    end
end;

# TODO: unfortunately, this is currently slower than the non-cache version: 10x slower :cry:
# @btime getindex($patchwise_dist, $p, $q) # 526.684 ns (3 allocations: 448 bytes)
patchwise_dist[p, q] == sqeuclidean(img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ])</code></pre><pre class="documenter-example-output">true</pre><hr/><p><em>This page was generated using <a href="https://github.com/johnnychen94/DemoCards.jl">DemoCards.jl</a> and <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 16 October 2020 02:04">Friday 16 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

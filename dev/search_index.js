var documenterSearchIndex = {"docs":
[{"location":"democards/examples/image processing/block_matching/#Block-matching","page":"Block matching","title":"Block matching","text":"","category":"section"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"(Image: Source code) (Image: notebook) (Image: Author) (Image: Update time)","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"Block matching algorithm is one key stage in patch-based image processing algorithm. This example shows how block matching algorithm can be implemented efficiently and easily with the help of LazyDistances.jl.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"using Images\nusing TestImages\nusing LazyDistances\n\nimg = imresize(float.(testimage(\"cameraman\")), (64, 64))","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"For given patch radius rₚ, we can get a patch at each pixel p in the image.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"p = CartesianIndex(20, 30)\nrₚ = CartesianIndex(3, 3) # patch size (7, 7)\npatch_p = img[p-rₚ:p+rₚ]","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"For each pixel p, what block matching does is to find a group of patches that are similar to patch_p.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"function block_matching(f, img, p, rₚ; num_patches=10)\n    R = CartesianIndices(img)\n    # to simplify the implementation and not consider border case\n    candidates = first(R)+rₚ:last(R)-rₚ\n\n    # Measure the similarity of two patches with `f`. Typically, `f` is `sqeuclidean`\n    patch_p = @view img[p-rₚ:p+rₚ]\n    dist = map(candidates) do q\n        patch_q = @view img[q-rₚ:q+rₚ]\n        f(patch_p, patch_q)\n    end |> vec\n\n    # sort from small(the most similar) to large(the least similar)\n    # TODO: use partialsortperm! to reduce allocation\n    order = partialsortperm(dist, 1:num_patches) # 34.394 μs (4 allocations: 26.44 KiB)\n    qs = @view candidates[order]\nend","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"Here we get a group of patches that are similar to patch_p in the sense of F-norm.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"matched_patches = block_matching(SqEuclidean(), img, p, rₚ) # 212.266 μs (7 allocations: 39.83 KiB)\nmosaicview(map(q->img[q-rₚ:q+rₚ], matched_patches); npad=2, nrow=2)","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"This implementation looks good, but there's one key challenge here, that we need to loop over the whole image and do block matching for each pixel. This means we are doing a massive computation and there are a lot of unnecessary redundant calculation if we are doing a simple loop.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"For example, this is what a naive implementation of patch-based algorithm might looks like","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"function patched_mean(img, rₚ; num_patches=10)\n    out = fill(zero(eltype(img)), axes(img))\n\n    R = CartesianIndices(img)\n    for p in first(R)+rₚ:last(R)-rₚ\n        matched_patches = block_matching(SqEuclidean(), img, p, rₚ; num_patches=num_patches)\n        out[p] = mapreduce(q->img[q], +, matched_patches)/length(matched_patches)\n    end\n    out\nend\n\npatched_mean(img, rₚ) # 794.575 ms (23549 allocations: 130.86 MiB)","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"What's wrong here? There are a lot of repeated calculation in f(patch_q, patch_q). For example, when f = SqEuclidean()","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"d = sum_p q (Ip - Iq)^2","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"Please do note that (I[p] -  I[q])^2 is repeatedly calculated in the whole iteration. One single calculation of such is not expensive, but it is a siginficant amount of work when it's in a nested for-loops.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"Among all the existing MATLAB and Python implementations, there are two things done to work around this key challenge. The first workaround is to pre-calculate the pixelwise distances and then reuse it in the inner loop. It works quite well but it also introduces another key challenge, that the memeory will complain for large image size; to store the result for image with size (256, 256) we need an array of size (256, 256, 256, 256), which is 32 GB memory and unaccptable. The second workaround, is then to specify a search window, that to only search similar patches in a larger neighborhood of pixel p. For search window size (17, 17), the memeory needed to store the result is 0.14 GB, which is more acceptable.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"We are not going to explore how search window and pre-calculation are implemented because this is quite a dirty work; you almost have to write the whole implementation in a long long for-loop. Instead, we are going to see how this can be efficiently and easily implemented with LazyDistances.jl.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"A PairwiseDistance is a lazy array that mimics the output of pairwise distance.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"eval_op(x, y) = abs2(x - y)\npointwise_dist = PairwiseDistance(eval_op, img, img); # 1.982 ns (0 allocations: 0 bytes)\n\n# pointwise_dist[I, J] is defined as f(img[I], img[J])\npq1 = pointwise_dist[CartesianIndex(1, 1), CartesianIndex(2, 2)]\npq2 = eval_op(img[CartesianIndex(1, 1)], img[CartesianIndex(2, 2)])\npq1 == pq2","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"Generating this array does not doing any actual computation; the computation does not happen until you ask for the data. We can also build a patchwise distance with this.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"R = CartesianIndices(img)\nvalid_R = first(R)+rₚ:last(R)-rₚ\n\n# For simplicity, we didn't deal with boundary condition here, so it will error\n# when we index with `patchwise_dist[1, 1, 1, 1]`.\npatchwise_dist = let rₚ = rₚ, img = img\n        PairwiseDistance(SqEuclidean(), img, img) do p, q\n        # here we specify how patches are generated from given pixel p and q\n        p, q = CartesianIndex(p), CartesianIndex(q)\n        @views img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ]\n    end\nend; # 4.903 ns (0 allocations: 0 bytes)\n\np = CartesianIndex(4, 4)\nq = CartesianIndex(5, 5)\n# @btime getindex($patchwise_dist, $p, $q) # 54.374 ns (0 allocations: 0 bytes)\npatchwise_dist[p, q] == sqeuclidean(img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ])","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"This way we have generated the patchwise distances, although the actual computation doesn't happen until we need it.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"function patched_mean_fast(img, rₚ; num_patches=10)\n    out = fill(zero(eltype(img)), axes(img))\n\n    patchwise_dist = PairwiseDistance(SqEuclidean(), img, img) do p, q\n        p, q = CartesianIndex(p), CartesianIndex(q)\n        @views img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ]\n    end\n\n    R = CartesianIndices(img)\n    R0 = first(R)+rₚ:last(R)-rₚ\n    for p in R0\n        dist = vec(patchwise_dist[p, R0])\n        matched_patches = R0[partialsortperm(dist, 1:num_patches)]\n        out[p] = mapreduce(q->img[q], +, matched_patches)/length(matched_patches)\n    end\n    out\nend\n\n# @btime patched_mean_fast($img, rₚ);\n#  657.075 ms (26913 allocations: 131.63 MiB)\n# @btime patched_mean($img, rₚ);\n#  797.023 ms (23549 allocations: 130.86 MiB)\npatched_mean_fast(img, rₚ) == patched_mean(img, rₚ)","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"Great! We haven't incoporate the pre-calculation trick yet, we still get a bit faster by making things lazy.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"More generally speaking, pre-calculation is just a cache. PairwiseDistance supports a so-called LocalWindow cache which stores the results in neighborhood (p, q-r:q+r) for each pixel pair (p, q).","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"eval_op(x, y) = abs2(x - y)\npointwise_dist = PairwiseDistance(eval_op, img, img, LocalWindowCache((7, 7))) # 32.575 μs (3 allocations: 980.12 KiB)\n\npq1 = pointwise_dist[CartesianIndex(1, 1), CartesianIndex(2, 2)]\npq2 = eval_op(img[CartesianIndex(1, 1)], img[CartesianIndex(2, 2)])\npq1 == pq2","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"This requires a bit more memory because we will allocate a cache array of size (64, 64, 7, 7), which is about 788 KB memory for Float32 type. Reusing the cache requires us to implement the SqEuclidean function on it. Lucikly we can get this done very efficiently and quickly in Julia.","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"patchwise_dist = let img=img, rₚ=rₚ\n        eval_op(x, y) = abs2(x - y)\n        pointwise_dist = PairwiseDistance(eval_op, img, img, LocalWindowCache((7, 7)))\n\n        patch_eval_op(patch_p, patch_q) = mapreduce((p, q)->pointwise_dist[p, q], +, patch_p, patch_q)\n        PairwiseDistance{Float32}(patch_eval_op, img, img) do p, q\n        p, q = CartesianIndex(p), CartesianIndex(q)\n        p-rₚ:p+rₚ, q-rₚ:q+rₚ\n    end\nend;\n\n# TODO: unfortunately, this is currently slower than the non-cache version: 10x slower :cry:\n# @btime getindex($patchwise_dist, $p, $q) # 526.684 ns (3 allocations: 448 bytes)\npatchwise_dist[p, q] == sqeuclidean(img[p-rₚ:p+rₚ], img[q-rₚ:q+rₚ])","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"","category":"page"},{"location":"democards/examples/image processing/block_matching/","page":"Block matching","title":"Block matching","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LazyDistances","category":"page"},{"location":"#LazyDistances","page":"Home","title":"LazyDistances","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LazyDistances]","category":"page"},{"location":"#LazyDistances.PairwiseDistance","page":"Home","title":"LazyDistances.PairwiseDistance","text":"PairwiseDistance(f, A, B, [cache_strategy=NullCache()])\n\nLazily calculate the pairwise result of two arrays A, B with function f.\n\nThe output dist::PairwiseDistance is a read-only array type, where dist[i, j] is defined as f(A[i], B[j]).\n\nEach item dist[i, j] is computed lazily during getindex, which could be expensive for non-trivial f. cache_strategy provides a way to automatically store some of the result as cache. The default strategy is NullCache(), which means no cache is enabled.\n\nwarning: Warning\nHow data is cached is internal implementation details and you generally should not talk to cache directly.\n\nExamples\n\njulia> using LazyDistances, Distances\n\njulia> A, B = rand(1:5, 6), rand(1:5, 4);\n\njulia> dist = PairwiseDistance(Euclidean(), A, B)\n6×4 PairwiseDistance{Float64, 2, Euclidean, LazyDistances.CachedViews.NullCacheArray{Float64, 2, Tuple{Base.OneTo{Int64}}, Tuple{Base.OneTo{Int64}}}, Array{Int64,1}, Array{Int64,1}}:\n 1.0  1.0  2.0  2.0\n 4.0  4.0  1.0  1.0\n 2.0  2.0  1.0  1.0\n 4.0  4.0  1.0  1.0\n 0.0  0.0  3.0  3.0\n 2.0  2.0  1.0  1.0\n\n\n\n\n\n","category":"type"}]
}
